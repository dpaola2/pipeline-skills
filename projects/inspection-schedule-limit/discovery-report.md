# Increase Inspection Schedule Limit - Discovery Report

> **Generated by:** Pipeline Stage 1 (Discovery)
> **Date:** February 6, 2026
> **PRD:** `projects/inspection-schedule-limit/prd.md`
> **Linear:** [ENG-362](https://linear.app/orangeqc/issue/ENG-362/increase-number-of-total-inspection-schedules-beyond-600)

---

## 1. PRD Understanding

### Feature Summary
Raise the per-account inspection schedule limit from 600 to 1,000, surface a clear validation error when the limit is reached, and add job duration logging to the daily batch scheduling job. This is a stopgap — the scheduling system is being rearchitected in 2026.

### Entities Identified
| Entity | PRD Reference | Existing? | Current Location |
|--------|--------------|-----------|-----------------|
| InspectionSchedule | LIM-001 | Yes | `app/models/inspection_schedule.rb` |
| InspectionScheduleForm (join) | — | Yes | `app/models/inspection_schedule_form.rb` |
| InspectionSchedulesStructure (join) | — | Yes | `app/models/inspection_schedules_structure.rb` |
| InspectionEvent (generated events) | OBS-001 | Yes | `app/models/inspection_event.rb` |
| InspectionScheduleEventsProcessor (job) | OBS-001 | Yes | `app/jobs/inspection_schedule_events_processor.rb` |
| InspectionScheduleEventsBuilder (service) | OBS-001 | Yes | `app/services/builders/inspection_schedule_events_builder.rb` |
| InspectionScheduleBuilder (service) | — | Yes | `app/services/builders/inspection_schedule_builder.rb` |
| Batch rake task | OBS-001 | Yes | `lib/tasks/inspection_schedules.rake` |
| Schedule limit constant | LIM-002 | **No** | Currently a magic number `600` inline in controller and view |

### Platforms Affected
- [x] Rails (Web Admin)
- [ ] Rails (API) — API has no schedule creation endpoint; only a `preview` collection route
- [ ] iOS — N/A (Level 2, web-only project)
- [ ] Android — N/A (Level 2, web-only project)

---

## 2. Current State: Rails

### Related Models

| Model | File | Key Associations | Notes |
|-------|------|------------------|-------|
| InspectionSchedule | `app/models/inspection_schedule.rb` | `belongs_to :account`, `has_many :inspection_schedule_forms`, `has_many :inspection_forms through:`, `has_many :inspection_schedules_structures`, `has_many :structures through:`, `has_many :inspection_events`, `belongs_to :assignee (polymorphic: User/Group)` | Includes `Archivable` (soft delete via `deleted_at`). Enum: `period` (`:weekly`, `:monthly`). Recurrence stored as JSONB in `recurrence_rules`. Uses IceCube gem. |
| InspectionScheduleForm | `app/models/inspection_schedule_form.rb` | `belongs_to :inspection_schedule`, `belongs_to :inspection_form` | Join table — 4 lines |
| InspectionSchedulesStructure | `app/models/inspection_schedules_structure.rb` | `belongs_to :inspection_schedule`, `belongs_to :structure` | Join table — 4 lines |
| InspectionEvent | `app/models/inspection_event.rb` | `belongs_to :account`, `belongs_to :inspection_schedule`, `belongs_to :structure`, `belongs_to :inspection_form` | Generated events with `due_on` and `original_due_on`. `inspection_id` is nil until a user completes the inspection. |

### Current Schema (Related Tables)

```ruby
# inspection_schedules (Tier 2: ~12,746 rows, 9 MB total)
create_table "inspection_schedules", id: :serial do |t|
  t.integer  "account_id"
  t.string   "name"
  t.integer  "period"              # enum: 0=weekly, 1=monthly
  t.jsonb    "recurrence_rules"    # IceCube rule hash
  t.datetime "deleted_at"          # soft delete (Archivable)
  t.datetime "paused_at"           # nil when active/unpaused
  t.datetime "created_at"
  t.datetime "updated_at"
  t.integer  "assignee_id"        # polymorphic
  t.string   "assignee_type"
  t.index ["account_id"]
  t.index ["assignee_id"]
  t.index ["assignee_type"]
  t.index ["deleted_at"]
  t.index ["paused_at"]
end

# inspection_schedule_forms (~15,006 rows, 2.4 MB)
create_table "inspection_schedule_forms" do |t|
  t.bigint "inspection_schedule_id", null: false
  t.bigint "inspection_form_id", null: false
  t.index ["inspection_schedule_id", "inspection_form_id"], unique: true
end

# inspection_schedules_structures (~38,901 rows, 6 MB)
create_table "inspection_schedules_structures", id: :serial do |t|
  t.integer  "inspection_schedule_id"
  t.integer  "structure_id"
  t.datetime "created_at"
  t.datetime "updated_at"
  t.index ["inspection_schedule_id"]
  t.index ["structure_id"]
end

# inspection_events (~2.1M rows, 1.1 GB total — Tier 1)
create_table "inspection_events", id: :serial do |t|
  t.integer  "account_id", null: false
  t.string   "name"
  t.integer  "inspection_schedule_id"
  t.integer  "structure_id", null: false
  t.integer  "inspection_form_id", null: false
  t.integer  "inspection_id"       # nil until completed
  t.datetime "deleted_at"
  t.datetime "created_at"
  t.datetime "updated_at"
  t.integer  "assignee_id"
  t.string   "assignee_type"
  t.date     "due_on"
  t.date     "original_due_on"
  # Multiple indexes on account_id, structure_id, inspection_form_id, due_on, etc.
end
```

### Where the 600 Limit Is Enforced

The limit exists in exactly **two locations**, both UI-only:

**1. Controller check** — `app/controllers/inspection_schedules_controller.rb:12`
```ruby
@at_limit = current_account.inspection_schedules.active.count >= 600
```

**2. View alert** — `app/views/inspection_schedules/index.html.erb:56-62`
```erb
<% if @at_limit %>
  <div class='panel-body'>
    <div class="alert alert-danger" role="alert">
      <strong>Maximum Number of Schedules!</strong> Your account currently has
      the maximum number of 600 inspection schedules. Please delete unused
      schedules or condense your setup.
    </div>
  </div>
<% end %>
```

**3. "New Schedule" button hidden** — `app/views/inspection_schedules/index.html.erb:39`
```erb
<% unless @at_limit %>
  <div class="pull-right">
    <button class="btn btn-primary dropdown-toggle" ...>New Schedule</button>
    ...
  </div>
<% end %>
```

**Critical finding:** The limit is **UI-only** — there is no model validation, no controller `before_action`, and no API enforcement. The `create` action does not check the limit before saving. If a user bypassed the UI (e.g., direct POST), they could create schedules beyond 600. The `@at_limit` flag only controls whether the "New Schedule" button is visible and whether the warning banner is shown.

### Related Controllers

| Controller | File | Actions | Auth Pattern |
|-----------|------|---------|--------------|
| InspectionSchedulesController | `app/controllers/inspection_schedules_controller.rb` | index, new, show, create, edit, update, update_state | `before_action :require_inspection_schedule_permissions` |

Key behaviors:
- `index` (line 8-28): Checks limit, loads filtered/paginated schedules
- `create` (line 62-80): Uses `Builders::InspectionScheduleBuilder.new(builder_params).build` — does NOT check limit
- `update_state` (line 124-134): Handles pause/unpause/delete via builder

### Related Services

| Service | File | Purpose |
|---------|------|---------|
| `Builders::InspectionScheduleBuilder` | `app/services/builders/inspection_schedule_builder.rb` | Creates/updates/deletes schedules. Enqueues `InspectionScheduleEventsProcessor` for background processing. |
| `Builders::InspectionScheduleEventsBuilder` | `app/services/builders/inspection_schedule_events_builder.rb` | Generates `inspection_events` from a schedule's IceCube recurrence rules. Has `build_all` class method for batch processing. |
| `Analytics::InspectionSchedules` | `app/services/analytics/inspection_schedules.rb` | Filter logic for the index page (structures, forms, assignee). |
| `InspectionSchedulePresenter` | `app/presenters/inspection_schedule_presenter.rb` | View logic — summary text, location/form display, `occurs_today?` check. |

### Related Background Jobs

| Job | File | Purpose |
|-----|------|---------|
| `InspectionScheduleEventsProcessor` | `app/jobs/inspection_schedule_events_processor.rb` | Per-schedule job. Triggered on create/update/pause/unpause/delete. Processes ONE schedule: calculates occurrences from now to end-of-next-month, creates `inspection_events`. |
| `InspectionEventsBatchProcessor` | `app/jobs/inspection_events_batch_processor.rb` | Unrelated batch job for inspection events. |

### Batch Rake Task (The "Daily Job")

**File:** `lib/tasks/inspection_schedules.rake`

```ruby
task process_inspection_schedules: :environment do
  check_in_id = Sentry.capture_check_in("process-inspection-schedules", :in_progress)

  now = Time.current
  end_of_next_month = (now + 1.month).end_of_month

  if Date.current.end_of_month == Date.current
    Rails.logger.info "[InspectionSchedules] Skipping last day of month..."
  elsif Date.current.beginning_of_month == Date.current
    Rails.logger.info "[InspectionSchedules] Skipping first day of month..."
  else
    Rails.logger.info "[InspectionSchedules] Starting process..."
    build_options = { start_time: now, end_time: end_of_next_month }
    Builders::InspectionScheduleEventsBuilder.build_all(build_options, sleep: 1)
    completed_time = Time.current
    Rails.logger.info "[InspectionSchedules] Completed at #{completed_time} with total time #{completed_time - now} seconds"
  end

  Sentry.capture_check_in("process-inspection-schedules", :ok, check_in_id: check_in_id)
end
```

Key observations:
- Runs daily (presumably via Heroku Scheduler)
- Skips first and last day of each month (edge case avoidance)
- Iterates ALL active/unpaused schedules globally via `find_each` with a 1-second sleep between each schedule
- **Already logs total duration** (line 21: `"Completed at #{completed_time} with total time #{completed_time - now} seconds"`)
- **Already has Sentry check-in monitoring** (`capture_check_in` at start/end)
- With ~12,746 total schedules and 1-second sleep, minimum runtime ≈ 3.5 hours (not including processing time per schedule)

### `build_all` Implementation

**File:** `app/services/builders/inspection_schedule_events_builder.rb:5-14`

```ruby
def self.build_all(build_options, options={})
  InspectionSchedule.active.unpaused.find_each do |schedule|
    Time.zone = schedule.account.owner.time_zone if schedule.account.owner
    events_builder = InspectionScheduleEventsBuilder.new(schedule, build_options)
    events_builder.build
    sleep options[:sleep] if options[:sleep].present?
  end
end
```

Per-schedule `build` method:
1. For each inspection_form in the schedule → get subleaf structure IDs → create events for each (structure, form, due_date) triple
2. Events are idempotent — only created if they don't already exist for that (structure, form, due_date)
3. Processing time scales with: `num_forms × num_subleaf_structures × num_occurrences`

### Related API Endpoints

| Method | Path | Purpose | Response Shape |
|--------|------|---------|---------------|
| GET | `/api/v4/inspection_schedules/preview` | Preview schedule occurrences | N/A — collection-only route |

There is **no API endpoint for creating schedules**. Schedule creation is web-only.

### Related Routes

```ruby
# Web routes (config/routes.rb:32-34)
resources :inspection_schedules, except: :destroy do
  put :update_state
end

# API v4 routes (config/routes.rb:310-312)
resources :inspection_schedules, only: [] do
  get :preview, on: :collection
end
```

### Related Views

| View | File | Notes |
|------|------|-------|
| Index | `app/views/inspection_schedules/index.html.erb` | Bootstrap 3. Shows limit warning, hides "New Schedule" button at limit. |
| Show | `app/views/inspection_schedules/show.html.erb` | Schedule detail with 6-month preview. |
| Form | `app/views/inspection_schedules/_form.html.erb` | Create/edit form. |
| New | `app/views/inspection_schedules/new.html.erb` | Wraps form partial. |
| Edit | `app/views/inspection_schedules/edit.html.erb` | Wraps form partial. |

All views are in `app/views/` (Bootstrap 3), not `app/views_tailwind/`.

### Related Tests

| Test File | Coverage | Type |
|-----------|----------|------|
| `spec/models/inspection_schedule_spec.rb` (234 lines) | Validations, `.accessible_to`, `#deserialize_recurrence_rules`, `#to_ice_cube`, `#editable_by`, `#incinerate` | Model spec |
| `spec/requests/inspection_schedules_spec.rb` (57 lines) | GET index (success), GET edit (success with deleted structure handling) | Request spec |
| `spec/presenters/inspection_schedule_presenter_spec.rb` (106 lines) | `#locations`, `#occurs_today?`, `#forms` | Presenter spec |
| `spec/services/builders/inspection_schedule_builder_spec.rb` | `#update_state` (pause, unpause, delete), `#update`, processor enqueuing | Builder spec |
| `spec/services/builders/inspection_schedule_events_builder_spec.rb` (798 lines) | `.build_all`, `#reset`, `#pause`, `#unpause`, `#delete`, `#build` with extensive edge cases (idempotency, timezone handling, multiple forms, account owner changes) | Events builder spec |
| `spec/factories/inspection_schedule.rb` | Factory with `weekly` trait | Factory |

**No test coverage for the 600 limit** — no spec tests that the limit is enforced or that the UI shows the warning.

### Feature Flag

`scheduled_inspections_enabled` — boolean column on the `accounts` table (default: `false`). Controls whether the entire scheduling feature is accessible. Additionally, `Account::MINIMUM_INSPECTORS_FOR_INSPECTION_SCHEDULING_ACCESS = 10` requires the account to have at least 10 inspector seats.

---

## 3. Current State: iOS

N/A — Level 2 (web-only) project.

---

## 4. Current State: Android

N/A — Level 2 (web-only) project.

---

## 5. Cross-Platform Patterns

### Data Flow
```
User creates schedule via web form
  → InspectionSchedulesController#create
    → Builders::InspectionScheduleBuilder#build
      → saves InspectionSchedule record + join tables
      → enqueues InspectionScheduleEventsProcessor (Delayed Job)
        → Builders::InspectionScheduleEventsBuilder#build
          → creates InspectionEvent records for each (form, structure, due_date)

Daily batch job (Heroku Scheduler)
  → process_inspection_schedules rake task
    → Builders::InspectionScheduleEventsBuilder.build_all
      → iterates ALL active/unpaused schedules
      → for each: creates missing events from now to end-of-next-month
      → sleeps 1 second between schedules
```

### How Similar Features Are Built

The inspection schedule feature follows standard OrangeQC patterns:
- **Builder pattern** for complex create/update (like other builders in `app/services/builders/`)
- **Delayed Job** for background processing
- **Presenter** (SimpleDelegator) for view logic
- **Archivable** concern for soft delete
- **Account scoping** via `belongs_to :account` and `.accessible_to(user)` scopes
- **Permission gating** via `require_inspection_schedule_permissions` before_action

---

## 6. Technical Risks

| Risk | Severity | Details | Mitigation |
|------|----------|---------|------------|
| Limit is UI-only, not validated | Med | The `create` action does not check the count before saving. The limit is only enforced by hiding the "New Schedule" button. A direct POST request could bypass the limit. | Architecture should decide whether to add a model validation or keep it UI-only (matching existing behavior). |
| Daily batch job already takes ~3.5+ hours | Low | `build_all` processes ~12,746 schedules globally with 1-second sleep between each. Adding 400 more (PCSI ORG 2 growing from 600 to ~750) adds ~7 minutes. The incremental impact of raising the per-account limit is minimal on the global batch. | The batch job already logs total duration and has Sentry check-in monitoring. No additional mitigation needed for the limit change itself. |
| Per-schedule processing time at scale | Low | A single schedule with many forms × many structures generates many events. The concern isn't the number of schedules but the number of events per schedule (forms × subleaf structures × occurrences). This is independent of the account limit. | Monitor per-schedule processing time if OBS-002 is implemented. |
| No existing test for the limit | Low | There are no specs that test the 600 limit behavior (UI gate, error message, button hiding). The limit could be changed with no existing test breakage — but also no test would catch a regression. | Architecture should decide if limit tests are worth adding. |
| Magic number in two files | Low | `600` appears as a raw integer in the controller and as text in the view. No constant extracted. Easy to change one and miss the other. | Extract to a constant (LIM-002 in PRD). |

### Performance Concerns
- The daily batch job (`build_all`) is the primary performance bottleneck, but it's already functioning at ~12,746 schedules with a deliberate 1-second throttle. The limit change affects one account's count, not the global total meaningfully.
- Per-schedule event creation scales with `forms × subleaf_structures × occurrences_in_window`. For a schedule with 5 forms across a complex structure tree (hundreds of subleaves), a single schedule could generate thousands of events. This is the real scalability concern, not the number of schedules.

### Security Concerns
- No new security concerns. All queries are already account-scoped. The limit change doesn't affect query scoping.

---

## 7. Open Questions

| # | Question | Source | Blocking? |
|---|----------|--------|-----------|
| 1 | Should the limit be enforced as a model validation (preventing creation) or remain UI-only (hiding the button)? Currently it's UI-only — a direct POST bypasses the limit. The PRD says "validation prevents saving" (VAL-003), which is stronger than the current behavior. | PRD VAL-003 vs current behavior | No — architecture decision |
| 2 | The PRD requests job duration logging (OBS-001/OBS-002). The daily rake task already logs start/end time and total duration, and has Sentry check-in monitoring. Is the OBS requirement already satisfied, or is per-account/per-schedule granularity needed? | PRD OBS-001, rake task line 21 | No |
| 3 | The `BackgroundJobMetrics` module (included by `InspectionScheduleEventsProcessor`) only tracks enqueue counts via Librato, not duration. Is Librato still in use, or has monitoring moved entirely to Sentry? | `app/jobs/background_job_metrics.rb` | No |

---

## 8. Recommendations for Architecture Stage

- **The change is very small**: two magic numbers → one constant, update count check and view text. Optionally add a model validation.
- **Follow the existing pattern**: the `@at_limit` check in the controller + conditional rendering in the view is the established pattern. The constant extraction (LIM-002) is a clean improvement.
- **OBS-001 may already be satisfied**: the rake task logs duration and has Sentry check-ins. Review whether this meets the PRD intent before adding more instrumentation.
- **Consider adding a model validation**: the PRD explicitly says "validation prevents saving" (VAL-003). Currently there's nothing preventing a `POST /inspection_schedules` from succeeding even at 1000+ schedules. A `validate :schedule_limit_not_exceeded` on the model would be more robust than UI-only gating.
- **No database migration needed**: this is purely a code change (constant + validation + view text).
- **Test coverage gap**: no tests exist for the limit. Adding a spec that verifies the limit behavior would be prudent given this is being intentionally changed.
