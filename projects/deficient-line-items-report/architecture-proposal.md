# Deficient Line Item Report - Architecture Proposal

> **Generated by:** Pipeline Stage 2 (Architecture)
> **Date:** February 5, 2026
> **PRD:** `projects/deficient-line-items-report/prd.md`
> **Discovery Report:** `projects/deficient-line-items-report/discovery-report.md`
> **Linear:** TBD

---

## 1. Data Model Changes

### New Tables

```sql
CREATE TABLE report_settings (
  id bigserial PRIMARY KEY,
  user_id bigint NOT NULL REFERENCES users(id),
  report_type varchar NOT NULL,
  settings jsonb NOT NULL DEFAULT '{}',
  created_at timestamptz NOT NULL DEFAULT NOW(),
  updated_at timestamptz NOT NULL DEFAULT NOW()
);

-- Unique constraint: one settings row per user per report type
CREATE UNIQUE INDEX idx_report_settings_user_report_type
  ON report_settings (user_id, report_type);
```

**Design rationale:** A generic `report_settings` table with `report_type` + `jsonb` avoids polluting the `users` table with feature-specific columns and can serve future reports (e.g., if we add configurable thresholds to other reports later). The `jsonb` column stores a small, well-defined JSON object — no arbitrary nesting. The unique index on `(user_id, report_type)` ensures exactly one settings row per user per report.

For the deficient line item report, the settings JSON structure is:

```json
{
  "repeat_threshold": 2,
  "minimum_sample_size": 5,
  "high_risk_threshold": 60
}
```

### Modified Tables

No modifications to existing tables.

### Rails Models

```ruby
# app/models/report_setting.rb
class ReportSetting < ApplicationRecord
  DEFICIENT_LINE_ITEMS = "deficient_line_items"

  DEFAULTS = {
    DEFICIENT_LINE_ITEMS => {
      "repeat_threshold" => 2,
      "minimum_sample_size" => 5,
      "high_risk_threshold" => 60
    }.freeze
  }.freeze

  belongs_to :user

  validates :report_type, presence: true,
    uniqueness: { scope: :user_id }
  validates :settings, presence: true

  def self.for(user, report_type)
    find_or_initialize_by(user: user, report_type: report_type).tap do |rs|
      rs.settings = DEFAULTS.fetch(report_type, {}).merge(rs.settings || {})
    end
  end

  def repeat_threshold
    settings["repeat_threshold"]
  end

  def minimum_sample_size
    settings["minimum_sample_size"]
  end

  def high_risk_threshold
    settings["high_risk_threshold"]
  end
end
```

### Associations Map

```
User 1──* ReportSetting (keyed by report_type)

User 1──* SupervisoryZone *──1 Structure
                                  │
InspectionItem *──1 Inspection *──┘
      │
      └──1 LineItem *──1 Account (scoping)
```

### Migration Plan

| Migration | Type | Notes |
|-----------|------|-------|
| Create `report_settings` | DDL | Standard `create_table`. Small table, no special handling needed. |
| Add unique index on `(user_id, report_type)` | DDL | Created inline with table — table is new, no concurrent index needed. |

### Expected Data Volumes

| Table | Expected Records | Access Frequency | Growth Rate |
|-------|-----------------|------------------|-------------|
| report_settings | ~49K max (one per user per report) | Low — read on report load, write on threshold save | Grows with user count, not usage |

---

## 2. New Analytics Service

### `Analytics::DeficientLineItems`

This is the core service class that powers all report queries. It follows the established `Analytics::Filters` pattern exactly.

```ruby
# app/services/analytics/deficient_line_items.rb
module Analytics
  class DeficientLineItems
    include Filters

    def initialize(user, options = {}, defaults = {})
      super
      @report_settings = ReportSetting.for(user, ReportSetting::DEFICIENT_LINE_ITEMS)
    end

    attr_reader :report_settings

    # --- Entry View: Summary Cards ---

    def total_deficiencies
      scoped_deficient_items.count
    end

    def total_inspected
      scoped_inspection_items.count
    end

    def overall_deficiency_rate
      return 0 if total_inspected.zero?
      (total_deficiencies.to_f / total_inspected * 100).round(1)
    end

    def line_items_tracked
      qualifying_line_items.count
    end

    # Prior period summary for trend badge on Overall Deficiency Rate card
    def prior_period_deficiency_rate
      return nil if prior_scoped_inspection_items.count.zero?
      prior_def = prior_scoped_deficient_items.count
      prior_total = prior_scoped_inspection_items.count
      (prior_def.to_f / prior_total * 100).round(1)
    end

    # --- Entry View: Line Item Table ---
    # Returns ActiveRecord::Result rows with computed columns.
    # Each row: line_item_id, line_item_name, deficient_count, total_count,
    #           deficiency_rate, unique_areas, avg_score, prior_deficiency_rate
    def qualifying_line_items(sort_column: "deficiency_rate", sort_direction: "DESC", page: 1, per_page: 25)
      base = scoped_inspection_items
        .joins(:line_item)
        .where(line_items: { account_id: current_account.id })
        .group("line_items.id, line_items.name")

      # Compute current period metrics
      base
        .select("line_items.id AS line_item_id")
        .select("line_items.name AS line_item_name")
        .select("COUNT(CASE WHEN inspection_items.deficient = TRUE THEN 1 END) AS deficient_count")
        .select("COUNT(inspection_items.id) AS total_count")
        .select("ROUND(COUNT(CASE WHEN inspection_items.deficient = TRUE THEN 1 END) * 100.0 / NULLIF(COUNT(inspection_items.id), 0), 1) AS deficiency_rate")
        .select("COUNT(DISTINCT inspections.structure_id) FILTER (WHERE inspection_items.deficient = TRUE) AS unique_areas")
        .select("ROUND(AVG(inspection_items.score * 100.0) FILTER (WHERE inspection_items.deficient = TRUE), 1) AS avg_score")
        .having("COUNT(CASE WHEN inspection_items.deficient = TRUE THEN 1 END) >= ?", report_settings.repeat_threshold)
        .having("COUNT(inspection_items.id) >= ?", report_settings.minimum_sample_size)
        .order("#{sanitize_sort(sort_column)} #{sanitize_direction(sort_direction)}")
        .offset((page - 1) * per_page)
        .limit(per_page)
    end

    # Count of qualifying line items (for pagination)
    def qualifying_line_items_count
      # Subquery to count groups matching HAVING clause
      sub = scoped_inspection_items
        .joins(:line_item)
        .where(line_items: { account_id: current_account.id })
        .group("line_items.id")
        .having("COUNT(CASE WHEN inspection_items.deficient = TRUE THEN 1 END) >= ?", report_settings.repeat_threshold)
        .having("COUNT(inspection_items.id) >= ?", report_settings.minimum_sample_size)
        .select("1")

      InspectionItem.from("(#{sub.to_sql}) AS qualifying").count
    end

    # --- Drill-Down View: Area Concentration ---
    # Given a line_item_id and optional parent structure,
    # returns metrics grouped by direct child structures.
    def area_concentration(line_item_id:, parent_structure: nil)
      child_structures = if parent_structure
        parent_structure.children.active
      else
        # Top-level: user's supervisory structures
        current_user.supervisory_structures.active
      end

      child_structures.map do |structure|
        subtree_items = scoped_inspection_items
          .where(line_item_id: line_item_id)
          .within_subtrees([structure])

        deficient_count = subtree_items.deficient.count
        total_count = subtree_items.count
        next if total_count.zero?

        {
          structure: structure,
          deficient_count: deficient_count,
          total_count: total_count,
          deficiency_rate: (deficient_count.to_f / total_count * 100).round(1),
          avg_score: subtree_items.deficient.has_score.average("inspection_items.score * 100.0")&.round(1),
          has_children: structure.active_children_count > 0
        }
      end.compact.sort_by { |row| -row[:deficiency_rate] }
    end

    # --- Drill-Down View: Inspection Form Comparison (leaf level) ---
    def form_comparison(line_item_id:, structure:)
      items = scoped_inspection_items
        .where(line_item_id: line_item_id)
        .joins(:inspection)
        .where(inspections: { structure_id: structure.id })

      items
        .joins(inspection: :inspection_form)
        .group("inspection_forms.id, inspection_forms.name")
        .select("inspection_forms.id AS form_id")
        .select("inspection_forms.name AS form_name")
        .select("COUNT(CASE WHEN inspection_items.deficient = TRUE THEN 1 END) AS deficient_count")
        .select("COUNT(inspection_items.id) AS total_count")
        .select("ROUND(COUNT(CASE WHEN inspection_items.deficient = TRUE THEN 1 END) * 100.0 / NULLIF(COUNT(inspection_items.id), 0), 1) AS deficiency_rate")
        .select("ROUND(AVG(inspection_items.score * 100.0) FILTER (WHERE inspection_items.deficient = TRUE), 1) AS avg_score")
        .order("deficiency_rate DESC")
    end

    # --- Drill-Down View: Trend Chart ---
    # Returns time-bucketed deficiency data for a line item,
    # optionally scoped to a structure subtree.
    def trend_data(line_item_id:, structure: nil)
      items = scoped_inspection_items.where(line_item_id: line_item_id)
      items = items.within_subtrees([structure]) if structure

      grouping = suggested_grouping_by_time
      items
        .joins(:inspection)
        .select("date_trunc('#{grouping}', inspections.ended_at) AS period")
        .select("COUNT(inspection_items.id) AS total_count")
        .select("COUNT(CASE WHEN inspection_items.deficient = TRUE THEN 1 END) AS deficient_count")
        .group("period")
        .order("period ASC")
    end

    # --- Drill-Down View: Summary Cards ---
    def drill_down_summary(line_item_id:, structure: nil)
      items = scoped_inspection_items.where(line_item_id: line_item_id)
      items = items.within_subtrees([structure]) if structure

      deficient_count = items.deficient.count
      total_count = items.count
      unique_areas = items.deficient.joins(:inspection).select("DISTINCT inspections.structure_id").count
      total_areas = items.joins(:inspection).select("DISTINCT inspections.structure_id").count
      avg_score = items.deficient.has_score.average("inspection_items.score * 100.0")&.round(1)

      {
        deficient_count: deficient_count,
        total_count: total_count,
        deficiency_rate: total_count.zero? ? 0 : (deficient_count.to_f / total_count * 100).round(1),
        unique_areas: unique_areas,
        total_areas_inspected: total_areas,
        avg_score: avg_score
      }
    end

    # --- Trend Calculation ---
    # Returns :worsening, :improving, :flat, or nil (no prior data)
    def trend_badge(current_rate:, prior_rate:)
      return nil if prior_rate.nil?
      diff = current_rate - prior_rate
      if diff > 5
        :worsening
      elsif diff < -5
        :improving
      else
        :flat
      end
    end

    # --- Per-line-item trend for entry table ---
    def prior_period_rates_for(line_item_ids)
      return {} if line_item_ids.empty?

      prior_scoped_inspection_items
        .where(line_item_id: line_item_ids)
        .joins(:line_item)
        .group("line_items.id")
        .select("line_items.id AS line_item_id")
        .select("ROUND(COUNT(CASE WHEN inspection_items.deficient = TRUE THEN 1 END) * 100.0 / NULLIF(COUNT(inspection_items.id), 0), 1) AS prior_deficiency_rate")
        .index_by(&:line_item_id)
    end

    private

    def scoped_inspection_items
      @scoped_inspection_items ||= build_scoped_items(start_date, end_date)
    end

    def scoped_deficient_items
      @scoped_deficient_items ||= scoped_inspection_items.deficient
    end

    # Prior period: same duration, immediately preceding
    def prior_start_date
      duration = end_date.to_date - start_date.to_date
      start_date.to_date - duration
    end

    def prior_end_date
      start_date.to_date - 1.day
    end

    def prior_scoped_inspection_items
      @prior_scoped_inspection_items ||= build_scoped_items(prior_start_date, prior_end_date)
    end

    def prior_scoped_deficient_items
      @prior_scoped_deficient_items ||= prior_scoped_inspection_items.deficient
    end

    def build_scoped_items(from, to)
      relation = InspectionItem
        .accessible_to(current_user)
        .between(from, to)
        .active
        .applicable

      relation = apply_special_filters(relation)
      relation
    end

    def apply_special_filters(relation)
      if filtered_supervisory_structures?
        relation = relation.within_subtrees(scoped_supervisory_structures)
      end

      if forms.any?
        relation = relation.from_inspection_forms(forms)
      end

      relation
    end

    def sanitize_sort(column)
      %w[line_item_name deficient_count total_count deficiency_rate unique_areas avg_score].include?(column) ? column : "deficiency_rate"
    end

    def sanitize_direction(dir)
      dir.to_s.upcase == "ASC" ? "ASC" : "DESC"
    end
  end
end
```

**Key design decisions:**

1. **Includes `Analytics::Filters`** — gets `start_date`, `end_date`, `forms`, `structures`, `current_user`, `current_account` for free. Matches every other analytics service.

2. **Does NOT include `has_score` or `has_weight` in the base scope** — unlike `Analytics::InspectionItems` which filters to items with scores. The deficient line item report counts ALL applicable, active items (including those without scores) for the total count denominator. The `avg_score` calculation separately filters to `has_score` items only.

3. **Prior period computed as mirror duration** — e.g., if viewing Jan 1–31, prior period is Dec 1–31. Uses the same scoping chain as current period.

4. **`area_concentration` uses N queries** per visible area rather than one massive GROUP BY — this is intentional because each area's subtree requires `Structure.multiple_subtree_conditions` which generates OR-chain WHERE clauses that can't easily be combined into a single GROUP BY. The number of top-level areas is typically small (5–20). If this becomes a bottleneck, batch optimization is possible in a future iteration.

5. **`qualifying_line_items` uses PostgreSQL `FILTER` syntax** — cleaner than CASE/WHEN for conditional aggregates. Supported since PostgreSQL 9.4.

---

## 3. Controller Design

### Routes

```ruby
# config/routes.rb — inside the existing `namespace :reports do` block
namespace :reports do
  # ... existing routes ...
  resources :deficient_line_items, only: [:index, :show]
  resource :deficient_line_item_settings, only: [:update]
end
```

| Route | Method | Path | Purpose |
|-------|--------|------|---------|
| Entry view | GET | `/reports/deficient_line_items` | Summary cards + line item table |
| Drill-down | GET | `/reports/deficient_line_items/:id` | Line item detail (`:id` = `line_item_id`) |
| Save settings | PATCH | `/reports/deficient_line_item_settings` | Persist user thresholds |

### Controller

```ruby
# app/controllers/reports/deficient_line_items_controller.rb
class Reports::DeficientLineItemsController < Reports::BaseController
  before_action :require_read_inspections_permission

  layout 'webapp'

  def index
    @title = ["Deficient Line Item Report"]
    @filters = Analytics::FilterSelection.new(current_user, params)
    @analytics = Analytics::DeficientLineItems.new(current_user, params)
    @report_settings = @analytics.report_settings

    @line_items = @analytics.qualifying_line_items(
      sort_column: params[:sort] || "deficiency_rate",
      sort_direction: params[:direction] || "DESC",
      page: (params[:page] || 1).to_i,
      per_page: 25
    )

    # Batch fetch prior period rates for trend badges
    line_item_ids = @line_items.map(&:line_item_id)
    @prior_rates = @analytics.prior_period_rates_for(line_item_ids)

    @total_pages = (@analytics.qualifying_line_items_count / 25.0).ceil
  end

  def show
    @title = ["Deficient Line Item Report"]
    @filters = Analytics::FilterSelection.new(current_user, params)
    @analytics = Analytics::DeficientLineItems.new(current_user, params)
    @report_settings = @analytics.report_settings

    @line_item = current_account.line_items.find(params[:id])
    @summary = @analytics.drill_down_summary(
      line_item_id: @line_item.id,
      structure: selected_structure
    )

    # Prior period for trend badge
    prior_summary = @analytics.drill_down_summary(
      line_item_id: @line_item.id,
      structure: selected_structure
    )
    # (computed via prior_period methods in analytics)

    @trend_data = @analytics.trend_data(
      line_item_id: @line_item.id,
      structure: selected_structure
    )

    if selected_structure && selected_structure.active_children_count == 0
      # Leaf area: show inspection form comparison
      @forms = @analytics.form_comparison(
        line_item_id: @line_item.id,
        structure: selected_structure
      )
    else
      # Non-leaf or top level: show area concentration
      @areas = @analytics.area_concentration(
        line_item_id: @line_item.id,
        parent_structure: selected_structure
      )

      # Mixed scenario: also show forms directly at this area
      if selected_structure
        @direct_forms = @analytics.form_comparison(
          line_item_id: @line_item.id,
          structure: selected_structure
        )
      end
    end
  end

  private

  def selected_structure
    @selected_structure ||= if params[:structure_id].present?
      Structure.accessible_to(current_user).find(params[:structure_id])
    end
  end
end
```

```ruby
# app/controllers/reports/deficient_line_item_settings_controller.rb
class Reports::DeficientLineItemSettingsController < Reports::BaseController
  def update
    setting = ReportSetting.for(current_user, ReportSetting::DEFICIENT_LINE_ITEMS)
    setting.settings = setting.settings.merge(setting_params)

    if setting.save
      redirect_back fallback_location: reports_deficient_line_items_path, notice: "Settings saved."
    else
      redirect_back fallback_location: reports_deficient_line_items_path, alert: "Could not save settings."
    end
  end

  private

  def setting_params
    params.require(:report_setting).permit(:repeat_threshold, :minimum_sample_size, :high_risk_threshold).to_h.transform_values(&:to_i)
  end
end
```

**Design rationale:**

- Inherits from `Reports::BaseController` → gets `require_read_reports_permission` and `set_default_date_range` (45-day default) for free.
- Also calls `require_read_inspections_permission` to match the Overall Report pattern (since inspection data is being accessed).
- Settings controller is a separate singular resource — clean separation, standard RESTful pattern.
- Drill-down uses `structure_id` param for area navigation, matching the existing Overall Report pattern (`@filters.filtered_params.merge(structure_ids: area.id)`).

---

## 4. View Architecture

### View File Structure

```
app/views/reports/deficient_line_items/
  index.html.erb                    # Entry view
  show.html.erb                     # Drill-down view
  _defaults_banner.html.erb         # Threshold display + Edit Defaults button
  _summary_cards.html.erb           # Four/five summary metric cards
  _line_item_table.html.erb         # Sortable line item table (entry view)
  _area_concentration.html.erb      # Area table (drill-down)
  _form_comparison.html.erb         # Inspection form table (leaf level)
  _trend_chart.html.erb             # Bar chart container (Stimulus-powered)
  _filters.html.erb                 # Date picker + filter button
  _breadcrumbs.html.erb             # Drill-down breadcrumb navigation
  _edit_defaults_modal.html.erb     # Threshold configuration modal
  _filter_panel.html.erb            # Slide-out filter panel
  _export_modal.html.erb            # Export format selection modal
  _risk_bar.html.erb                # Colored deficiency rate bar partial
  _pagination.html.erb              # Page controls
```

### Key View Patterns

**Date filter:** Reuse `shared/_daterange_picker.html.erb` + `date_range_picker_controller.js` Stimulus controller. The existing infrastructure supports predefined ranges and custom date selection.

**Filter panel (slide-out):** New Stimulus controller `deficient_line_items_filter_controller.js`. The hierarchical area tree will be built from `current_user.supervisory_structures` with lazy-loaded children via Stimulus. Inspection form checkboxes are a flat list.

**Sortable tables:** Follow existing pattern using `tablesorter-bootstrap` CSS classes and `js-table-sortable`. Column headers are links that re-submit with `sort` and `direction` params.

**Trend chart:** New Stimulus controller `deficient_line_items_chart_controller.js`. Renders a stacked bar chart using **Chart.js** (already available in the asset pipeline — used by existing dashboard charts). The chart reads data from `data-*` attributes or an inline `<script>` tag with JSON.

**Modals:** Standard Bootstrap modal pattern (already used throughout the app for similar overlays).

**Risk bar:** A small inline partial rendering a colored `<div>` with width proportional to the deficiency rate. Colors: green (<35%), amber (35%–threshold), red (>= threshold).

### Stimulus Controllers

| Controller | File | Purpose |
|-----------|------|---------|
| `deficient_line_items_filter_controller` | `app/javascript/controllers/deficient_line_items_filter_controller.js` | Slide-out filter panel: area tree expand/collapse, search, checkbox selection, apply/clear |
| `deficient_line_items_chart_controller` | `app/javascript/controllers/deficient_line_items_chart_controller.js` | Trend bar chart rendering via Chart.js |
| `deficient_line_items_settings_controller` | `app/javascript/controllers/deficient_line_items_settings_controller.js` | Edit Defaults modal form submission (standard form, no AJAX needed — but controller manages modal open/close) |

---

## 5. Export Design

### New Exporters

Two new exporter classes, registered in `ReportExport::FACTORY_ADAPTERS`.

#### PDF: `Exporter::DeficientLineItemReportPdf`

```ruby
# app/services/exporter/deficient_line_item_report_pdf.rb
module Exporter
  class DeficientLineItemReportPdf
    include Exporter::PdfHelper

    REPORT_TYPE = "DeficientLineItemReportPdf"

    def self.handles?(report_export)
      report_export.report_type == REPORT_TYPE
    end

    attr_reader :report_export, :current_user

    def initialize(report_export)
      @report_export = report_export
      @current_user = report_export.user
    end

    def filename
      "#{filters.start_date.to_fs(:date)}-to-#{filters.end_date.to_fs(:date)}-deficient-line-items.pdf"
    end

    def content_type
      "application/pdf"
    end

    def perform
      # Generates Prawn PDF with:
      # 1. Header (account logo, report title, date range, threshold settings)
      # 2. Summary cards section (if included)
      # 3. Line item table OR area concentration table (if included)
      # 4. Trend chart as embedded PNG (if drill-down and included)
      # Section inclusion controlled by report_export.parameters[:sections]
    end

    private

    def filters
      @filters ||= Analytics::FilterSelection.new(current_user, report_export.parameters)
    end

    def analytics
      @analytics ||= Analytics::DeficientLineItems.new(current_user, report_export.parameters)
    end

    def sections
      report_export.parameters[:sections] || ["summary_cards", "line_item_table"]
    end
  end
end
```

**Name choice:** `DeficientLineItemReportPdf` — distinct from existing `DeficientLineItemPdf` (which is per-inspection, not aggregated). The `Report` suffix makes the distinction clear.

**Trend chart in PDF:** Follow the existing `Shared::GraphImageHelper` pattern used by `OverallAveragePerformancePdf`. The chart is rendered server-side as a PNG image embedded in the Prawn document. This avoids needing browser rendering for the PDF.

#### CSV: `Exporter::DeficientLineItemReportCsv`

```ruby
# app/services/exporter/deficient_line_item_report_csv.rb
module Exporter
  class DeficientLineItemReportCsv
    include Exporter::Csvable

    REPORT_TYPE = "DeficientLineItemReportCsv"

    def self.handles?(report_export)
      report_export.report_type == REPORT_TYPE
    end

    attr_reader :report_export, :current_user

    def initialize(report_export)
      @report_export = report_export
      @current_user = report_export.user
    end

    def filename
      "#{filters.start_date.to_fs(:date)}-to-#{filters.end_date.to_fs(:date)}-deficient-line-items.csv"
    end

    def draw_csv
      CSV.generate do |csv|
        csv << [
          "Line Item", "Inspection Form", "Area (Full Path)", "Area (Top Level)",
          "Inspection Date", "Score", "Deficient", "Inspector", "Comment"
        ]

        scoped_items.find_each(batch_size: 1000) do |item|
          csv << [
            item.line_item.name,
            item.inspection.inspection_form.name,
            item.inspection.structure.location_path,
            item.inspection.structure.path.active.sites.first&.name,
            item.inspection.ended_at&.to_fs(:date),
            item.score.present? ? "#{(item.score * 100).round(1)}%" : "",
            item.deficient? ? "Yes" : "No",
            item.inspection.user.name,
            item.comments&.first&.body
          ]
        end
      end
    end

    def large_report?
      scoped_items.count > 10_000
    end

    private

    def filters
      @filters ||= Analytics::FilterSelection.new(current_user, report_export.parameters)
    end

    def scoped_items
      @scoped_items ||= begin
        items = InspectionItem
          .accessible_to(current_user)
          .between(filters.start_date, filters.end_date)
          .active
          .applicable
          .deficient
          .includes(:line_item, :comments, inspection: [:inspection_form, :structure, :user])

        if filters.forms.any?
          items = items.from_inspection_forms(filters.forms)
        end

        if filters.filtered_supervisory_structures?
          items = items.within_subtrees(filters.scoped_supervisory_structures)
        end

        # If drill-down, scope to specific line item
        if report_export.parameters[:line_item_id].present?
          items = items.where(line_item_id: report_export.parameters[:line_item_id])
        end

        items.order("inspections.ended_at DESC")
      end
    end
  end
end
```

**CSV grain:** Per the PRD (CSV-003), the CSV exports one row per individual inspection item at inspection-level grain. This is deficient items only (not all items). Uses `find_each` with batching for memory efficiency on large datasets.

### Export Factory Registration

```ruby
# In app/models/report_export.rb — add to FACTORY_ADAPTERS array:
Exporter::DeficientLineItemReportPdf,
Exporter::DeficientLineItemReportCsv,
```

### Export Flow

The export modal posts to `ReportExportsController#create` (existing) with:
- `report_type`: `"DeficientLineItemReportPdf"` or `"DeficientLineItemReportCsv"`
- `parameters`: current filter params + `sections` array (for PDF) + optional `line_item_id` (for drill-down)
- The existing `ReportExportProcessor` (Delayed::Job) handles async generation

---

## 6. Backwards Compatibility

### Compatibility Matrix

| Feature / Behavior | Web (current) | iOS (current) | Android (current) |
|-------------------|:---:|:---:|:---:|
| New report in Reports menu | Full | N/A | N/A |
| Existing reports unchanged | Full | Full | Full |
| Existing API endpoints unchanged | Full | Full | Full |
| Existing export formats unchanged | Full | Full | Full |

### Old Client Behavior

**iOS / Android (all versions):**
- No impact. This is a web-only report. No API endpoints are created or modified. Mobile apps do not display this report and are completely unaffected.

### API Versioning

Not applicable. No API endpoints are being created. This is a web-only feature using Rails views.

### Data Migration

No data migration needed. The `report_settings` table is new and starts empty. Settings are initialized with defaults on first access.

---

## 7. Security Design

### Query Scoping

| Resource | Scoping Chain |
|----------|--------------:|
| InspectionItem (report data) | `InspectionItem.accessible_to(current_user).between(dates).active.applicable` |
| LineItem (grouping key) | `.where(line_items: { account_id: current_account.id })` |
| Structure (area drill-down) | `Structure.accessible_to(current_user).find(params[:structure_id])` |
| ReportSetting (threshold persistence) | `ReportSetting.for(current_user, ...)` — always scoped to `current_user` |
| ReportExport (export) | `current_user.report_exports` — scoped via belongs_to |

### Authorization

| Action | Permitted Roles | Check |
|--------|----------------|-------|
| View report | Users with `read_reports` + `read_inspections` | `require_read_reports_permission` + `require_read_inspections_permission` (before_action) |
| Save thresholds | Same as view | Same controller, same before_actions |
| Export | Same as view | Export created via `current_user.report_exports` (scoped) |

### New Attack Surface

| Vector | Risk | Mitigation |
|--------|------|------------|
| Cross-tenant data via line_item_id param | Low | LineItem looked up via `current_account.line_items.find(id)` — scoped to account |
| Cross-tenant data via structure_id param | Low | Structure looked up via `Structure.accessible_to(current_user).find(id)` — scoped to user access |
| SQL injection via sort params | Low | `sanitize_sort` and `sanitize_direction` whitelist valid values |
| Report settings tampering | Low | Settings always read/written via `current_user` scope |
| Private inspection exposure | Low | `accessible_to(current_user)` already filters private inspections based on `can?(:read, :private_inspections)` |

---

## 8. Performance Strategy

### Query Performance

The core query aggregates across `inspection_items` (204M rows, Tier 0). The critical path is:

```sql
-- Simplified version of the entry view query
SELECT line_items.id, line_items.name,
       COUNT(CASE WHEN inspection_items.deficient THEN 1 END) AS deficient_count,
       COUNT(inspection_items.id) AS total_count
FROM inspection_items
JOIN inspections ON inspections.id = inspection_items.inspection_id
JOIN structures ON structures.id = inspections.structure_id
JOIN line_items ON line_items.id = inspection_items.line_item_id
WHERE inspections.ended_at BETWEEN $start AND $end
  AND inspection_items.deleted_at IS NULL
  AND inspection_items.not_applicable_at IS NULL
  AND [supervisory_zone_conditions]
GROUP BY line_items.id, line_items.name
HAVING COUNT(CASE WHEN deficient THEN 1 END) >= $repeat_threshold
   AND COUNT(inspection_items.id) >= $min_sample
ORDER BY deficiency_rate DESC
LIMIT 25 OFFSET 0;
```

### Index Analysis

**Existing indexes that help:**
- `multi_inspections_not_deleted` on `inspections(structure_id, ended_at, inspection_form_id) WHERE deleted_at IS NULL` — helps the date range + structure join
- `index_inspection_items_on_line_item_id` — helps the line_item join
- `index_inspection_items_on_inspection_id` — helps the inspection join

**New index recommendation:**

```sql
-- This index is NOT proposed for V1.
-- Monitor query performance in production first.
-- If the entry view query exceeds acceptable response times (>3s),
-- consider adding a partial index:
--
-- CREATE INDEX CONCURRENTLY idx_inspection_items_deficiency_report
--   ON inspection_items (line_item_id, deficient)
--   WHERE deleted_at IS NULL AND not_applicable_at IS NULL;
--
-- This would be a TIER 0 table migration requiring:
--   disable_ddl_transaction!
--   CREATE INDEX CONCURRENTLY (non-blocking)
--   Careful timing (off-peak hours)
```

**Recommendation: Do NOT add a new index for V1.** The existing indexes plus the date range filter (which significantly narrows the working set from 204M to the ~45-day window) should provide acceptable performance. The date range on `inspections.ended_at` is the most selective predicate — a 45-day window on a table with years of data eliminates >90% of rows before the join to `inspection_items`.

**If performance is insufficient after launch**, the partial index above is the recommended addition. It should be validated with `EXPLAIN ANALYZE` against a production snapshot first.

### Other Performance Considerations

- **Pagination (25 per page):** Limits the result set and avoids computing all line items at once.
- **Batch trend calculation:** `prior_period_rates_for` computes all prior rates in a single query (batched by line_item_ids on the current page), avoiding N+1.
- **Area concentration N+1:** The drill-down issues one query per visible area. This is acceptable because the number of top-level areas is typically small (5–20). Each individual query is fast because it's scoped to a single subtree.
- **CSV export batching:** `find_each(batch_size: 1000)` prevents loading all rows into memory.
- **Large report guard:** CSV exports with >10K rows trigger the "large report" confirmation flow (existing pattern).

---

## 9. Export Impact

| Export | Format | Changes | Backwards Compatible? |
|-------|--------|---------|----------------------|
| Existing `DeficientLineItemPdf` | PDF | No changes | Yes — untouched |
| Existing `LowestLineItemCsv` / `HighestLineItemCsv` | CSV | No changes | Yes — untouched |
| New `DeficientLineItemReportPdf` | PDF | Net new | N/A — new |
| New `DeficientLineItemReportCsv` | CSV | Net new | N/A — new |

No existing exports are modified. The new exporters are additive.

---

## 10. Open Questions for Human Review

| # | Question | Options | Recommendation |
|---|----------|---------|---------------|
| 1 | **"Avg Score" for mixed rating types:** The PRD says "average score of deficient instances only." `inspection_items.score` is stored as 0.0–1.0 for percentage types but may be NULL for points types. How should we handle deficient items with NULL scores? | A: Skip them in the average (only average items with scores) / B: Treat NULL as 0 / C: Display separate avg for percentage vs points | **A: Skip NULL scores.** Display `AVG(score) FILTER (WHERE deficient AND score IS NOT NULL)`. Items with no score don't contribute to the average. This is consistent with the existing `has_score` scope pattern. If an account uses only points-based ratings and scores are always NULL, the Avg Score column displays "N/A". |
| 2 | **Default date range:** The PRD says "defaults to the current period" (FLT-016). `Reports::BaseController` defaults to 45 days. What should this report use? | A: 45 days (match BaseController) / B: 90 days (match Analytics::Filters) / C: Current calendar month | **A: 45 days.** Inherit from `Reports::BaseController` for consistency with all other reports. The PRD's "current period" is ambiguous; 45 days is the established convention. Users can adjust. |
| 3 | **Filter panel implementation:** The PRD specifies a slide-out filter panel with hierarchical area tree, search, and checkboxes. Should this be a Stimulus-driven panel that submits a standard form, or a Turbo Frame with server-side rendering? | A: Stimulus + standard form submission / B: Turbo Frame | **A: Stimulus + form.** Consistent with existing filter patterns. The area tree structure comes from initial page load data. Search is client-side filtering of the rendered tree. Form submission reloads the page with filter params. |
| 4 | **Unified PDF export vs. per-section:** The PRD suggests a unified export pattern (PDF-010) but says to fall back to per-section if scope is high. Should V1 support section checkboxes in the export modal? | A: Section checkboxes (unified pattern) / B: Single full PDF (simpler) | **A: Section checkboxes.** The implementation cost is low — the PDF builder already generates sections sequentially. Adding a `sections` parameter that controls which sections are rendered is straightforward. This pilots the unified export pattern the PRD envisions. |
| 5 | **Chart.js vs. server-side chart for PDF:** The web view uses Chart.js (client-side). The PDF needs a static image. Should we use the existing `GraphImageHelper` pattern for PDF chart generation, or render the Chart.js canvas to PNG and send it to the server? | A: Server-side chart via GraphImageHelper (existing pattern) / B: Client-to-server canvas export | **A: Server-side via GraphImageHelper.** Consistent with existing `OverallAveragePerformancePdf`. Avoids complexity of client-to-server image transfer. The chart is a simple stacked bar chart that Prawn can generate directly. |

---

## 11. Alternatives Considered

### Alternative: Store thresholds as columns on the `users` table

**Description:** Add `deficient_li_repeat_threshold`, `deficient_li_min_sample`, `deficient_li_high_risk_threshold` columns directly to the `users` table.

**Pros:** Simpler — no new table, no joins. Values always available on the user object.

**Cons:** Pollutes the `users` table with feature-specific columns. If future reports need configurable thresholds, more columns pile up. The `users` table is already wide.

**Why rejected:** The `report_settings` table with `report_type` + `jsonb` is only marginally more complex but is extensible. New reports with thresholds add a row, not a migration.

### Alternative: Pre-aggregate deficiency data into a materialized view

**Description:** Create a materialized view (or background job) that pre-computes deficiency rates per line item per account, refreshed periodically.

**Pros:** Eliminates the real-time aggregation query against the 204M-row table. Guaranteed fast reads.

**Cons:** Adds operational complexity (refresh scheduling, staleness, cache invalidation when inspections are created). Users see stale data. Doesn't help with the drill-down queries which are scoped to specific structures and time ranges.

**Why rejected:** The date range filter is the most selective predicate and should narrow the working set dramatically. Real-time aggregation is simpler and provides fresh data. If performance is insufficient post-launch, we can add a covering index or consider pre-aggregation as a later optimization.

### Alternative: Build drill-down as a single-page app with Turbo/AJAX

**Description:** Make the drill-down navigation entirely client-side with Turbo Frame lazy-loading or AJAX calls.

**Pros:** Smoother UX — no full page reloads when drilling down. Preserves scroll position.

**Cons:** Significantly more complex front-end architecture. The existing report pattern uses full-page navigations with query params. Adds testing complexity.

**Why rejected:** The existing reports all use full-page navigations. Following the established pattern is faster to build, easier to test, and consistent with the rest of the app. The drill-down URL structure (`/reports/deficient_line_items/:id?structure_id=X`) supports bookmarkability and browser back navigation for free.

---

## 12. Summary

### Files to Create

| File | Purpose |
|------|---------|
| `db/migrate/XXXXXX_create_report_settings.rb` | Create `report_settings` table |
| `app/models/report_setting.rb` | ReportSetting model |
| `app/services/analytics/deficient_line_items.rb` | Core analytics service |
| `app/controllers/reports/deficient_line_items_controller.rb` | Entry view + drill-down controller |
| `app/controllers/reports/deficient_line_item_settings_controller.rb` | Threshold settings controller |
| `app/views/reports/deficient_line_items/index.html.erb` | Entry view |
| `app/views/reports/deficient_line_items/show.html.erb` | Drill-down view |
| `app/views/reports/deficient_line_items/_defaults_banner.html.erb` | Threshold display banner |
| `app/views/reports/deficient_line_items/_summary_cards.html.erb` | Summary metric cards |
| `app/views/reports/deficient_line_items/_line_item_table.html.erb` | Sortable line item table |
| `app/views/reports/deficient_line_items/_area_concentration.html.erb` | Area drill-down table |
| `app/views/reports/deficient_line_items/_form_comparison.html.erb` | Inspection form table |
| `app/views/reports/deficient_line_items/_trend_chart.html.erb` | Bar chart container |
| `app/views/reports/deficient_line_items/_filters.html.erb` | Date picker + filter controls |
| `app/views/reports/deficient_line_items/_breadcrumbs.html.erb` | Drill-down navigation |
| `app/views/reports/deficient_line_items/_edit_defaults_modal.html.erb` | Threshold config modal |
| `app/views/reports/deficient_line_items/_filter_panel.html.erb` | Slide-out filter panel |
| `app/views/reports/deficient_line_items/_export_modal.html.erb` | Export format selection |
| `app/views/reports/deficient_line_items/_risk_bar.html.erb` | Deficiency rate color bar |
| `app/views/reports/deficient_line_items/_pagination.html.erb` | Page controls |
| `app/javascript/controllers/deficient_line_items_filter_controller.js` | Filter panel Stimulus controller |
| `app/javascript/controllers/deficient_line_items_chart_controller.js` | Trend chart Stimulus controller |
| `app/javascript/controllers/deficient_line_items_settings_controller.js` | Settings modal Stimulus controller |
| `app/services/exporter/deficient_line_item_report_pdf.rb` | PDF exporter |
| `app/services/exporter/deficient_line_item_report_csv.rb` | CSV exporter |
| `spec/models/report_setting_spec.rb` | ReportSetting model spec |
| `spec/services/analytics/deficient_line_items_spec.rb` | Analytics service spec |
| `spec/controllers/reports/deficient_line_items_controller_spec.rb` | Controller spec |
| `spec/services/exporter/deficient_line_item_report_pdf_spec.rb` | PDF export spec |
| `spec/services/exporter/deficient_line_item_report_csv_spec.rb` | CSV export spec |

### Files to Modify

| File | Changes |
|------|---------|
| `config/routes.rb` | Add `reports/deficient_line_items` and `reports/deficient_line_item_settings` routes |
| `app/models/report_export.rb` | Add `Exporter::DeficientLineItemReportPdf` and `Exporter::DeficientLineItemReportCsv` to `FACTORY_ADAPTERS` |
| `app/views/reports/index.html.erb` | Add "Deficient Line Item Report" entry to the reports menu (with `can?(:read, :inspections)` guard) |

---

## Approval Checklist

> **This architecture proposal requires human review and approval before the gameplan is generated.**

### Reviewer: ___________
### Date: ___________
### Status: Pending

#### Must Verify
- [ ] Data model is architecturally sound (`report_settings` table with `jsonb`, unique index on `(user_id, report_type)`)
- [ ] Analytics service follows existing patterns (`Analytics::Filters` inclusion, `accessible_to`, `between`, `active`, `applicable`)
- [ ] Controller inherits from `Reports::BaseController` and uses correct authorization
- [ ] Security scoping is correct (all queries scoped to account, authorization checked, structure access validated)
- [ ] No new indexes on Tier 0 tables in V1 (deferred to post-launch if needed)
- [ ] Export naming avoids collision with existing `DeficientLineItemPdf`

#### Should Check
- [ ] `qualifying_line_items` query uses PostgreSQL `FILTER` syntax correctly
- [ ] Prior period calculation (mirror duration) matches PRD's "prior equivalent period" definition
- [ ] CSV export grain (one row per deficient inspection item) matches PRD CSV-003
- [ ] Trend badge thresholds (±5 percentage points) match PRD TRD-003/TRD-004
- [ ] Area concentration drill-down handles mixed areas (sub-areas + direct forms) per DDV-050
- [ ] Report Settings model defaults match PRD (repeat: 2, sample: 5, high risk: 60%)
- [ ] Export section selection approach is feasible for the PDF builder

#### Notes
[Reviewer notes, modifications requested, or rejection reasons]
